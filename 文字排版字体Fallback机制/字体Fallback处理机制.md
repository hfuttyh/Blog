# 字体排版引擎底层Fallback处理机制介绍 #

## 1.什么是排版字体Fallback机制？ ##

文字排版引擎的Fallback机制其实是一种保护机制，为了在文本内容最终显示的时候，不会由于给定的字体（或字体列表）字形不全导致无法显示。

假设让浏览器排版这么一段文本： **“阿拉伯语：عربية‎ لغة”**。
这是一段包含中文和阿拉伯文的混合文本，我们分别指定两种字体让浏览器去渲染：

```
<p style="font-family:楷体">阿拉伯语：عربية‎ لغة</p>
<p style="font-family:andalus">阿拉伯语：عربية‎ لغة</p>
```

显示出来是这样：

![阿拉伯语：عربية‎ لغة](./res/arabic.png)

首先我们知道楷体字体中并不包含阿拉伯文字的字形，同样Andalus字体中也没有中文文字的字形，但是无论我们指定使用哪种字体浏览器都能正确的显示出文字内容，区别只在于不同语言文字所使用的字体。

所以对于浏览器的排版引擎来说，虽然用户指定了一种字体，但是具体到文本中的每个字符最终使用何种字体排版还需要具体情况具体对待。如果遇到无法使用用户指定字体排版的字符就需要字体的Fallback机制了。

## 2.字体Fallback机制的技术实现 ##

知道了浏览器排版引擎的这种机制，那么技术上怎么实现呢？

字体Fallback技术就是： **如何判断指定的字体可以显示指定的文本内容，以及如何选择可以显示的替代字体**，其核心是判断 **字符（Character）和字体（Font）的包含关系**。这就需要利用字体文件（Font）中的**CMAP表**来查询是否包含要显示的字符。

### CMAP表 ###
**CMAP表** 是OpenType字体文件中用于定义 **字符编码** 到 **字形（Glyph）ID** 的映射表。所有字体支持的字符都可以通过这个表查询到相应的Glyph ID。而对于不支持的字符要么这个表查不到要么查到的Glyph ID会映射到0，也就是通常所说的（.nodef）。

首先CMAP表有一个表头:
![](res/cmap_header.png)
通过Platform ID和Encoding ID定义CMAP表使用的字符编码，不同的Platform对不同的Encoding ID有不同的定义。上图是在Platform ID=3（Microsoft）时Encoding ID对应的字符编码。通过表头可以找到对应编码的入口，然后根据具体的信息读取映射表内容就可以了，具体可以参考
[Character To Glyph Index Mapping Table](https://www.microsoft.com/typography/OTSPEC/cmap.htm)

### 字符映射表的建立和使用 ###

上述方案中最复杂的是字符映射表的建立和使用，目前比较通用的方案是采用类似SparseBitArray的位图表。这是由于Unicode标准会将相同语言的字符编码到同一个位面，也就是同一个编码区段，而字体文件一般也都是支持一种或多种语言，这就导致了字体文件的cmap也是一些离散的区段，所以使用稀疏位图来表示最好不过。

Unicode 9.0标准包含了大约1,114,112个字符，使用0x0-0x10FFFF来表示，在实现SparseBitArray时，首先我们定义2^8作为一个Page的大小，于是就有了0x10FF个Page，这个Page是稀疏存储的，通过一个索引数组来定位Page的起始偏移。而每个Page内（8位地址）可以表示256个字符编码，若每个编码使用1位表示是否包含，则一个Page需要256位才能完全表示，如果我们定义一个Element为uint32，那么一个Page需要4个Element来完全表示。经过这样的转换我们就可以以最少的内存占用将CMAP加载到内存中用于判断字符是否包含在字体文件中了。

![](res/SparseBitArray.png)

### 最终实现流程 ###

0. **确定不同语言的fallback默认字体**。 字体列表会受到不同平台自带字体的差异影响。一般会针对Windows、MAC、Linux、Android、iOS有不同的fallback列表。
1. **读取字体cmap信息，建立字符映射表**， 字符映射表一般只在用到的时候生成一次，需要做缓存
2. **将输入文本切分成性质一致的TextRun**，主要根据书写方向（bidi）、语言（script）来切分，一般都会利用ICU库来辅助判断
3. **遍历TextRun中的每一个字符，根据字符映射表确定最终字体。**
